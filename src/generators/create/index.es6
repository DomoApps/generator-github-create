import { Base } from 'yeoman-generator';
import * as github from '../shared/github';
import * as shell from '../shared/shell';
import merge from 'lodash.merge';
import find from 'lodash.find';
import path from 'path';

class GitCreateGenerator extends Base {

  constructor(...args) {
    super(...args);

    this.option('skip-prompt', {
      type: String,
      required: false,
      alias: 's',
      desc: 'Skip prompting.  You will either need to supply all arguments or the defaults will be used.'
    });

    this.option('user', {
      type: String,
      alias: 'u',
      desc: 'Github Username. Creates the repository on the user',
      defaults: false
    });

    this.option('init', {
      type: String,
      alias: 'i',
      desc: 'initialize local git'
    });

    this.option('push', {
      type: String,
      alias: 'p',
      desc: 'initial commit and push repository'
    });

    this.option('org', {
      type: String,
      alias: 'o',
      desc: 'Organization. Creates the repository on the org not the user',
      defaults: false
    });

    this.option('name', {
      type: String,
      alias: 'n',
      desc: 'Repository Name',
      defaults: path.basename(process.cwd())
    });

    this.option('description', {
      type: String,
      alias: 'd',
      desc: 'Repository Description',
      defaults: 'Repository generated by generator-github-create'
    });

    this.option('private', {
      type: String,
      alias: 'a',
      desc: 'Repository Access.  private|public',
      defaults: false
    });

  }

  initializing() {
    //Authenticate Github API
    /* istanbul ignore if */
    if (!github.get()) {
      this.composeWith('github-create:authenticate');
    }

    let config = {
      'skip-prompt': this.options['skip-prompt'],
      name: this.options.name,
      description: this.options.description,
      private: this.options.private,
      license: this.options.license,
      org: this.options.org,
      user: this.options.user,
      init: this.options.init,
      push: this.options.push
    };

    this.config.set('create', config);
    return this.config.save();
  }

  prompting() {
    let config = this.config.get('create');
    //Check for org config
    if (!config.org) {
      config.org = this.config.get('orgs') ? this.config.get('orgs').org : undefined;
      this.config.set('create', config);
    }

    if (config['skip-prompt']) {
      return true;
    }

    return github.getRepos(config)
      .then(repos => {
        return [
          {
            name: 'name',
            message: 'Repository Name',
            validate: (input) => { return ((find(repos, { name: input })) ? input + ' repository exists.' : true); },
            default: config.name
          },
          {
            name: 'description',
            message: 'Repository Description',
            default: config.description
          },
          {
            type: 'list',
            name: 'private',
            message: 'Access',
            default: config.private,
            choices: [
              {
                name: 'Public',
                value: false
              },
              {
                name: 'Private - You have to pay for this',
                value: true
              }
            ]
          },

        ];
      })
      .then(prompts => this.prompt(prompts))
      .then(answers => {
        //Hack to save user from authenticate config
        /* istanbul ignore if */
        if (!config.user) {
          answers.user = this.config.get('authenticate').username || undefined;
        }
        this.config.set('create', merge(this.config.get('create'), answers));
      })
      .then(() => {
        if (this.fs.exists('.git/config')) {
          this.log('Skipping Git Init:  Git is already initialized in this directoy.  You need to delete the .git folder before you can initialize and push this repository.');
          return [];
        }
        return [
          {
            type: 'confirm',
            name: 'init',
            message: 'Initialize Local Git?',
            default: true
          },
          {
            when: (answers) => { return answers.init; },
            type: 'confirm',
            name: 'push',
            message: 'Push initial commit?',
            default: true
          }
        ];
      })
      .then(prompts => this.prompt(prompts))
      .then(answers => {
        this.config.set('create', merge(this.config.get('create'), answers));
      });
  }

  configuring() {
    this.config.save();
  }

  default() {
    let config = this.config.get('create');

    return github.createRepository(this.config.get('create'))
      .then(repo => {
        this.config.set('create', merge(this.config.get('create'), { urls: [ repo.html_url, repo.ssh_url, repo.clone_url ] }));
        this.config.save();
        return this.config.get('create');
      })
      .then(config => shell.gitInit(config))
      .then(config => shell.gitRemote(config));
  }

  writing() {
    if (this.fs.exists(this.destinationPath('package.json'))) {
      //Write to package.json
      var pkg = this.fs.readJSON(this.destinationPath('package.json'), {});
      pkg.repository = {
        type: 'git',
        url: this.config.get('create').urls[2]
      };
      pkg.bugs = {
        url: this.config.get('create').urls[0] + '/issues'
      };
      pkg.homepage = this.config.get('create').urls[0] + '#readme';
      this.fs.writeJSON(this.destinationPath('package.json'), pkg);
    }
  }

  install() {
    if (this.config.get('create').push) {
      return shell.gitCommit()
        .then(() => shell.gitPush());
    }
  }

}

module.exports = GitCreateGenerator;
